I can search a talk object and all its nested components for a given search term. Search terms can be simple strings or regular expressions. I also support some advanced matching options, such as only matching whole worlds (#matchesWholeWord), being case-insensitive (#matchesCase), or doing a fuzzy search that also finds rough matches (#matchesFuzzy). My search terms can also be complex, allowing clients to search for multiple terms at once by separating them with spaces (see #partTerms).

I can process the matches of every search in multiple way: By implementing the TalkFilter interface, I can be used to select a subset of TalkConversation instances (category 'filtering'). But I can also output a list of all matches in the searched object (#matchesIn:), and I can even compile text excerpts from the original objects that contain all search results annotated with an emphasis (#resultsFromMatches:withAttributes:).

The nested components structure is defined by a visitor pattern. For this, TalkConversation and its component domain classes implement #visitBySearcher:context: from which they can tell back to the searcher for every relevant leaf and component of their own.